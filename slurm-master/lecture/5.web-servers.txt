Добрый день, зравствуйте.

Я расскажу как мы настраиваем и обслуживаем веб-сервера, а также затронем тему шифрования трафика.

Когда я готовил лекцию, то спросил у гугля "Что такое веб-сервер", в ответ получил пару тысяч ответов.
От предельно общих и популярных (что это сервер в сети "world wide web" ), до слишком сильно детализированных и академических (это HTTP-сервер, и далее полтора экрана текста).

Но в среднем все они говорили, что веб-сервер принимает запросы  и отвечает на них по протоколу HTTP.
И на мой взгляд данное определение достаточно емко и кратко характеризует такое понятие как веб-сервер и чем он отличается от других серверов.
Сформировать ответ веб сервер может самостоятельно, может выполнить какой-либо скрипт-программу и отдать результат ее работы,
а может передать запрос на другой сервер.

Задача администратора по большому счету всегда одинакова: 
  - убедить руководство и разработчиков использовать в качестве серверов оптимальные программные решения
  - настроить все, так чтобы оно работало быстро и без проблем

И первая в разы сложнее, чем вторая...

Одним из таких оптимальных решений, которые мы всегда советуем своим клиентам, не зависимо от того, какие решения, фреймворки или языки они используют 
для реализации своих бизнес задач - это использовать NGINX.

Nginx - это вебсервер, обратный прокси-сервер (таким затейливым образом названа ситуация, когда запросы от множества юзеров проксируются на один сервер,
 в отличии от обычного прокси), а также nginx умеет проксировать почтовые протоколы SMTP, IMAP. POP3 и даже просто произвольные TCP/UDP-сессии
Его конкурентами можно назвать haproxy и traefik, но на наш взгляд у haproxy запутанные и нелогичные конфиги,
а траефик слишком молод и ориентирован на работу в микросервисной среде.

Главное преимущество nginx - он быстрый, второй главное преимущество - он очень быстрый и при этом потребляет очень мало ресурсов и наконец третье - он работает без проблем, он не падает, у него не течет память и если что-то работает не правильно - проблема в бекенде или в конфигурации nginx, но никак не в глюках.

Начал его писать в 2002 году Игорь Сысоев, в 2004 появились первые публичные релизы. Основной идеей было создание маленького и быстрого сервера, который бы
освобождал тяжелый и медленный апач от необходимости ждать пока клиент выкачает с сервера результат обработки запроса, 
при чем если запрашивается статический файл, то этот файл будет отдан сразу, не беспокоя для этого апач, 
а если динамический контент, то nginx быстро получал ответ от апача, освобождая его для обработки следующего запроса, и передавал его клиенту, котороый получал его на скорости 33.6 кбит/с. 

На сегодняшний момент nginx умеет проксировать трафик на несколько серверов, осуществляя кеширование, распределение нагрузки и отказоустойчивость, обслуживать статические запросы, изменять полученные запросы, ограничивать скорость отдачи ответов, стримить видео-файлы, ограничивать доступ клиента по паролю или в зависимости от его адреса, наличия куки или заголовков в запросе, поддерживает шифрование трафика SSL и протокол HTTP/2. полный список на сайте nginx.org/ru
Также имеется достаточно большое количество дополнительных модулей, которые можно динамически подгружать, и которые существенно расширяют возможности nginx в обработке запросов. 
В идеальном случае вся предварительная обработка запроса должна происходить в nginx, а в бекенд должен проксироваться такой запрос, который бы там сразу выполнялся.
К сожалению, есть апач, который считает себя веб-сервером, достойным напрямую принимать запросы от пользователей, со своим подходом к обработке запросов.
Кстати, я читал интервью с автором nginx, так он говорит, что одним из мотивов для написания своего веб-сервера стала ситуация, когда после добавления директивы в один из виртуальных хостов апача у него переставал правильно работать другой виртуальный хост.

Давайте рассмотрим с какими же серверами, используемыми для генерации динамического контента мы сталкивались.

Во первых - что такое динамический контент - это результат обработки запроса неким программным кодом, который реализует логику работы сайта.
Обычно говорят говорят проще - сайт написан на таком-то языке или на такой-то системе CMS.

Естественно самый популярный язык для написания сайтов - это PHP, также очень часто встречаются сайты написаные на питоне и руби. 
Встречались сайты и сервисы, написанные на Perl, Go - но они уже проходили как экзотика.
В этот список можно включить Node.JS и JavaScript, но как правило сайты, написаные на node.js собираются в набор javascript, которые выполняются в браузере клиента - так называемый фронтенд, а вот node.js код, который надо запускать на сервере встречался всего пару раз.

Из систем CMS наиболее популярные написанные на php Bitrix, WordPress, Drupal, Joomla, для питона Django

В качестве сервера для запуска сайтов и систем, написанных на PHP предпочтительней использовать php-fpm, 
но к сожалению php-программисты очень любят апач и его файл конфигурации .htaccess, который они раскладывают по всему сайту где надо и не надо.

Поэтому продолжаем массово использовать apache и mod_php.
При увеличении популярности сайта, когда на него возрастает нагрузка, 
совместно с разработчиками проводим мероприятия по переводу на php 7.x и выполнение сайта через php-fpm
Как правило данные работы включают в себя перенос рерайтов из .htaccess в nginx, выделение в конфиге всех каталогов в которых разрешено/запрещено выполнение php скриптов.
Обычно запрещают там, куда юзер может загружать файлы, например каталог upload в битриксе

Для остальных языков запускаем специфические сервера
Для ruby обычно используем puma или unicorn
python запускаем с помощью uwsgi
nodejs запускали с помощью pm2

Если nginx и бекенд запущены на одном хосте, то для взаимодействия используем unix-сокет, сокеты умеют все, кроме apache.

Таким образом стандартная конфигурация для небольшого сайта на php - это nginx, который принимает запросы из интернета, отдает статику сам, а остальные запросы отдает апачу.
В случае необходимости добавляем puma или uwsgi.
Так как обычно все сайты на сервере принадлежат одной компании, задачи шаред хостинга обычно не стоит, поэтому апач работает из под своего юзера, но если нужно запускать обработку сайтов под разными системными пользователями мы используем mod_ruid2
В настройках php-fpm для каждого из сайтов используем отдельный пул.
руби и puma устанавливаем под отдельным пользователем с помощью rvm.io 
Для каждого проекта на python создаем свое виртуальное окружение virtual_env, туда же ставим uwsgi с помощью pip.
Каждый их сайтов на руби и питоне работают под своими отдельными юзерами.

Давайте рассмотрим структуру конфигурационных файлов веб-серверов.
Так как для каждого из проектов на руби и питоне мы запускаем индивидуальный веб-сервер, то и все настройки для пумы или uwsgi хранятся в каталоге проекта.

Настройки для nginx, apache и php-fpm разделяются на общие и индивидуальные для проекта.
с помощью директивы include настройки проектов включаются в общий конфиг сервера.

общая конфигурация веб-сервера загружается и обновляется на всех серверах автоматически
Что же она содержит:
nginx:
Настройки, влияющие на производительность
на безопасность
настройки default-сайта
настройки для служебного сайта - нужен для отдачи метрик мониторинга
Темплейты для конфигов виртуальных хостов.
и скрипты для обслуживания сервера:
  - конфиги для logrotate
  - лимиты на количество открытых файлов
  - конфиги для локального мониторинга - monit - ни разу еще не сработали, но иметь их надо
  - скрипты проверки конфигурации
  - сертификаты для default SSL

apache:
  Основной конфиг httpd.conf взят из дистрибутива, только закоментированы строчки для настройки параметров
  модуля prefork и директива Listen
  все остальные настройки в отдельных файлах, которые добавляются в общий
  Говорим апачу слушать на локалхосте, на порту 8080
  и задаем лимиты для prefork: 150 воркеров, рестартить после 4000 запросов - для этих настроек у нас в системе конфигурации больше всего уникальных конфигов. Конкретные значения лимитов зависят от нагрузки, выделенных ресурсов, поэтому для многих серверов используются свои лимиты, а не общие.
  настройки виртуального хоста для служебного сайта
  и настройка, которая указывает апачу, что он находится за прокси и IP адрес клиента надо брать не из TCP-сессии
  а из специального заголовка X-Real-IP
  в centos6 и centos7 используются разные версии apache, 2.2 и 2.4 соотвественно.
  в 2.2 используется модуль mod_rpaf - есть на гитхабе
  в 2.4 mod_remoteip - уже в поставке
и скрипты для обслуживания сервера:
  - конфиги для logrotate
  - конфиги для локального мониторинга - monit - алерты приходят регулярно
  - скрипты проверки конфигурации

И наконец php-fpm.d 
  тут практически стандартный конфиг из дистрибутива, только добавлен маленький пул, который используется
  для мониторинга и вывод метрик

Для создания конфигурации для сайтов мы используем самописный скрипт, которому на вход подаем название сайта
и он по шаблонам создает типичную конфигурацию для php-сайта
с php-fpm если он установлен, иначе с апачем в качестве бекенда.
Создает базу данных MySQL или PostgreSQL в зависимости от того, что установлено на сервере и прописывает логины-пароли в файлик
и создает FTP-аккаунт, чтобы php-программисты могли заливать сайт на сервер.
Да. в 2018 году все еще встречаются программисты, которые не умеют пользоваться гит.

Теперь давайте пройдемся по настройкам php:
Наши клиенты используют версии php от 5.3 до 7.2 

В настройках apache указано, что mod_php использует файл конфигурации /etc/httpd/conf.d/php.ini
В php практически все настройки можно задавать прямо в коде, и во всех CMS так и сделано.
Поэтому в основном конфиге устанавливаем вещи, влияющие на безопасность:
disable_functions действует только, если она задана в php.ini, переопределить ее нельзя
disable_functions = dl,shell_exec,exec,system,passthru,popen,proc_open,proc_nice,proc_get_status,proc_close,proc_terminate,posix_mkfifo,show_source,pcntl_fork

expose_php = Off - не сообщать всем подряд свою версию

error_reporting = E_ALL & ~E_DEPRECATED & ~E_STRICT & ~E_NOTICE - не выводить E_NOTICE в лог

Остальные настройки задаются в определении вирт хоста в апаче или пула в php-fpm
плюс то, что настроено в самом CMS
В темплейте у нас прописано задавать следующие настройки:

        php_admin_value open_basedir "##WWW_PATH##/##FQDN##:/usr/share/php"
        php_admin_value upload_tmp_dir "##WWW_PATH##/##FQDN##/tmp"
        php_admin_value session.save_path "##WWW_PATH##/##FQDN##/tmp"
        php_admin_value upload_max_filesize "256M"
        php_admin_value post_max_size "256M"
        php_admin_value memory_limit "256M"
        php_admin_value short_open_tag "On"
        php_admin_value date.timezone "Europe/Moscow"

Ограничиваем скрипты по памяти, по размеру входящих запросов,
 задаем ограничение на доступные каталоги в виде, указываем что php будет принимать файлы не в общий /tmp, а отдельный для каждого проекта.

Давайте подведем итоги к этой части лекции:
- Всегда используйте nginx, он позволяет очень гибко обращаться с веб-трафиком, умеет кешировать, ограничивать, балансировать, защищать от ddos и многое другое...
- Настройки серверов делятся на общие, которые настраиваются централизованно и индивидуальные.
- Практически все настройки можно переопределить из кода сайта, так что мы задаем только ограничение на запуск функций, обеспечивающих доступ к файловой системе и запуску программ и скриптов, а так же среднепотолочные лимиты на потребление памяти.
- К сожалению у php нет никаких секретных настроек, которые позволяют избавится от ошибок и ускорить сайт в 10 раз, единственный совет - не забывает ставить php-opcache или apc, переходите на php7


#### Вопрос! что показывать на практике. что на слайдах.
Будем ли мы им давать наш /srv/southbridge ?
сервера будем слаком создавать ? или ансиблем ?
могу для них сделать раз в час переналивку ансиблем - сказать мониту слать алерты локально, убрать заббикс, проверки также слать на root.

Практика: - создать сайт нашим скриптом, поставить php-fpm создать еще один сайт под php-fpm
Практика: - будем ли создавать сайты на руби и питоне ? - в принципе можно отдельными кусками

SSL/TLS/HTTPS
Теперь давайте поговорим о шифровании трафика в интернете:
На сегодня не защищать своих посетителей и не шифровать трафик - это просто неприлично, 
а особенно учитывая, что это можно делать бесплатно - совершенно нет никаких оправданий не использовать шифрование и не защищать своих клиентов.

Что же скрывается за буквами SSL/TLS/HTTPS и почему их все время путают ;)

SSL - это протокол, обеспечивающий аутентификацию и шифрование обмена данными. в использовании были версии 2 и 3. Версию 3 в 2014 году скомпрометировали и настоятельно рекомендуют не пользоваться ей.
TLS - это дальнейшее развитие протокола SSL, сейчас в ходу версии v1, v1.1, v1.2 - потихоньку приближается v1.3
А HTTPS - это протокол HTTP, который использует протокол SSL/TLS для шифрования обмена данным.
если вы ввели в браузере адрес, который начинается с https, то браузер создает зашифрованное соединение с сервером.
Если не указывать в адресной строке протокол, то современные браузеры сначала попробуют соединится по https

Как я уже сказал протокол обеспечивает две задачи:
Шифрование обмена данными: 
Оно осуществляется с помощью быстрого симметричного шифрования. 
ключ шифрования генерируется во время процедуры аутентификации по специальному алгоритму диффи-хелмана.

Аутентификацию противоположной стороны:
Для этого используется принцип криптосистемы с открытым ключем. 
Данная система позволяет кому угодно слать нам секретные сообщения, которые можем прочитать только мы.
Устроено это следующим образом: 
Генерируются два ключа - закрытый (приватный) и открытый (публичный). Открытый отдается всем желающим, с помощью него сообщения зашифровываются.
а расшифровать можно только с помощью закрытого ключа, который хранится в секрете.

Для того, чтобы все знали чей это открытый ключ, вместе с ним отдаются и атрибуты владельца (название сайта, организации, город, страна, срок действия)
и все это назвали сертификатом.
Решение проблемы доверия, когда клиент должен быть уверен, что получил настоящий сертификат от настоящего владельца, а не поддельный от злоумышленника решается следующим образом: Под честное слово. Честное слово удостоверяющего центра.

В мире есть несколько организаций, которые торгуют своим честным словом.
Когда мы хотим создать сертификат, которому бы доверяли в мире, то действуем следующим образом:
Создаем закрытый и открытый ключи, закрытый храним у себя в секрете и никому не показываем. а открытый ключ и свои атрибуты отсылаем удостоверяющему центру - это называется оправка CSR (крипто-сертификат реквест) - запрос на сертификат.
Удостоверяющий центр берет с нас деньги, удостоверяется, что атрибуты, которые мы прислали действительно принадлежат нам и если все хорошо - формирует файл с сертификатом. в этом файле содержится наш открытый ключ, наши атрибуты и подпись удостоверяющего центра (информация, зашифрованная закрытым ключом УЦ).

Открытые ключи все УЦ есть во всех браузерах. и когда браузер получает сертификат от сайта, то он расшифровывает подпись УЦ открытым ключом и если расшифровка прошла удачно, то сайт считается настоящим.

изначально все УЦ брали деньги за выпуск сертификата, потом появились китайцы, которые выпускали сертификаты бесплатно - можно было вручную отослать им CSR и получить сертификат на три года. Но потом нашли множество проблем в их системе подтверждения владения доменом, исследователями безопасности были получены от них сертификаты на домены github.com и google.com, и в итоге во всех браузерах корневые сертифкаты китайских УЦ пометили как скомпрометированные.
Apple, как всегда, вообще отказалась открывать сайты, на которых были установлены сертификаты, подписанные китайцами.

Но прогресс не остановить - появился lets encrypt. Новый бесплатный и автоматический удостоверящий центр. Его особенностью является то, что он выписывает сертификаты всего на 3 месяца, но он так же предоставляет способ автоматизировать выдачу новых сертификатов до истечения работы текущих.

letsencrypt использует протокол ACME, чтобы принять у вас запрос, проверить, являетесь ли вы владельцем домена, и выдать вам сертификат.
Есть множество решений, которые реализуют протокол ACME, мы у себя используем немного доработанную версию программы certbot.
Доработки состоят в следующем:
1. Она работает не от рута, а от обычного пользователя.
2. Она запакована в rpm.
3. Настроена для установки сертификатов в nginx и проверки владения доменом с помощью динамических токенов - webroot ()
4. В пакете дополнительно к программе есть кронтаск по автообновлению сертификата и перезагрузке nginx

При установке программа пишет краткую инструкцию по использованию, также наш скрипт admin.sh умеет 
запрашивать сертификат и вносить  все нужные изменения в конфигурацию nginx.

Проверить правильность настроек SSL можно на сайте SSLLabs http://www.ssllabs.com/ssltest
При наших настройках по умолчанию сайт получает оценку B, потому что не работает механизм Forward Secrecy. Прямая секретность означает, что если третья сторона узнает какой-либо сеансовый ключ, то она сможет получить лишь доступ к данным, защищенным лишь этим ключом. Механизм прямой секретности защищает ваши прошлые сессии от расшифровки при перехвате сеансового ключа в будущем.

Сгенерируем файл с параметрами для DHE-шифров

mkdir -p /etc/nginx/ssl
cd /etc/nginx/ssl
openssl dhparam -out dhparams.pem 2048; chmod 600 dhparams.pem
И включаем его использование в nginx:
    ssl_dhparam /etc/nginx/ssl/dhparams.pem;
Использовать только шифры, которые предлагает сервер
    ssl_prefer_server_ciphers on;

Эти настройки включены в общей части конфигурации:
Кеш для сессий
    ssl_session_cache shared:SSL:20m;
    ssl_session_timeout 10m;
Протоколы только TLS
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;

С такими настройками ssllabs дает нам оценку A

Раньше получить A+ можно было, указав вот эти шифры и добавив заголовок HSTS
    ssl_ciphers "EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA RC4 !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !MEDIUM";
Но ssllabs постоянно модифицируют свои требования, и на сегодня для получения оценки A+ надо отдавать HTTP заголовки с Content Security Policy, HSTS-заголовок, который требует, чтобы браузер обращался к сайту только по https, и даже если получит ссылку с протоколом http:// менял бы ее на https://
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload;"

Настройки для получения оценки A+ накладывают еще большие ограничение на клиентов, выключая совместимые шифры, и только новейшие версии браузеро и операционных смогут получить доступ к вашему сайту. Поэтому мы массово используем настройки, для которых ssllabs дает оценку B, но в тоже время эти настройки обсепечивают наилучшую совместимость с браузерами клиентов. Лучшее - враг хорошего.



Практика:
ставим letsencrypt, пробуем создать руками. пробуем создать через admin.sh
