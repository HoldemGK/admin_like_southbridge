Тема 1. Работайте как Southbridge. Основной регламент

1. Менеджмент в компании. Как организованы рабочие процессы

За 2,5 миллиона лет человечество несколько раз открывало для себя новые способы объединять усилия людей, каждый раз создавая значительно более совершенные модели. Фредерик Лалу, в своей книге “Открывая организации будущего” выделил семь стадий, через которые прошли организации во всем мире. Пять последних существуют до сих пор это: это красная, янтарная, оранжевая, зеленая и бирюзовая.

Нас интересуют последние три. В начале своего развития компания Southbridge была больше похожа на нечто среднее между оранжевой и зеленой организацией.

Цель оранжевой организации - победить в конкурентной борьбе, получить прирост и прибыль. Управление на этом уровне происходит по целям: контроль в процессе "что сделать" и свобода — в "как сделать". Это многие современные корпорации и частные школы. Ключевые открытия этой стадии развития: новаторство, ответственность, меритократия. Рост ради роста. К ним хорошо подходит цитата одного из героев "Красоты по-американски" Бадди Кейна ("короля недвижимости"): "Чтобы быть успешным, надо постоянно создавать образ успеха".
Обратная сторона оранжевых организаций — поощрение потребления через создание все новых потребностей. Успех измеряется исключительно деньгами и социальным признанием. Незаменимых сотрудников нет.

Зеленая организация становится неким спасательным кругом в "мире алчности", который пропагандируют оранжевые. Ведущая метафора зеленых — семья. На этом этапе у компаний появляется важность культуры, основанной на разделяемых всеми сотрудниками ценностях. Расширяются полномочия. Из минусов: отношения в компании-семье строятся по принципу "руководитель - это родитель и подчиненный - это ребенок"

По таким принципам работают большинство современных компаний. По прошествии времени у нас накопилось достаточное количество проблем связанных с данной моделью организации компании, остановимся на них и рассмотрим подробнее:

Во первых. Имитация бурной деятельности. До внедрения бирюзовой организации оплата всем сотрудникам начислялась по количеству отработанных часов. В итоге мы получили картину когда человек работал ради проставленных часов, а не ради результата. Решение задач искусственно затягивалось, затраченное время проставлялось необоснованно высокое. Главная цель сотрудника отработать 8 часовой рабочий день, и не важно сколько он за это время успел сделать по факту и как это отразится на компании.

Во вторых. Перекладывание ответственности на других. Всегда можно списать свои неудачи на руководство, не правильно определили дедлайн, не согласовали техническое задание и так далее.

В третьих. Скрытая неприязнь к руководству и как следствие не всегда добродушная атмосфера в коллективе.

В какой-то момент времени подобных проблем накопилось достаточно много и мы начали искать решение, решение пришло не сразу, на поиски были потрачены недели, а на полное внедрение месяцы. Решением оказалась “Бирюзовая организация”

Бирюзовая организация это “живой организм”. В ней нет иерархии. Зато есть:

- Самоуправление — взаимодействие равноправных коллег;
- Целостность — "будь на работе тем, кто ты есть в обычной жизни"
- Эволюционная цель: не старайся предвидеть изменения и контролировать будущее организации, а вслушайся и пойми, чем она хочет стать и какой цели ей хочется служить.

Звучит фантастически, не правда ли? Но не забываем, что выводы получены на основании анализа реальных эффективно работающих компаний. Иерархические отношения в них заменены на отношения равных, и пирамид не существует. А структуры выделяются следующие:

1. Параллельные команды. Деятельность организации распределена между командами без большой необходимости в координации между ними. Команды сами планируют свою работу, устанавливают необходимость инвестиций, распределяют бюджет. Иногда они нуждаются в командных коучах, вспомогательных командах или ролях.

2. Сеть индивидуальных контрактов. Похоже на работу в параллельных командах, но роли и обязательства сотрудников обсуждаются не в команде, а в серии встреч один на один с участием нескольких коллег. Обязательства могут быть формализованы в письменном документе.

3. Вложенные друг в друга команды. Один из подходов к управлению, впервые примененный в компании Ternary Software и известный многим как холакратия. Команды или так называемые “Круги” полностью автономны, самостоятельно принимают решения относительно ролей и обязанностей внутри команды. Разветвленная структура, состоящая из вложенных и соприкасающихся кругов.

На уровне Бирюзовых организаций изменения перестают быть предметом для обсуждений, потому что организация непрерывно адаптируется к окружающему миру изнутри. А конкурентов приглашают следовать вместе к высокой цели. Собрания высшего руководства отсутствуют. Координация и рабочие собрания проводятся, как только в них возникает потребность.

Бирюзовым организациям также свойственна высокая степень гибкости рабочего графика с учетом других важных жизненных обстоятельств сотрудника. Но при условии, что взятые на себя обязательства соблюдаются им. Это организация, где каждый вовлечен в процесс, чтобы коллективный разум смог выявить наилучшее решение.

Теперь перейдем к тому что выиграли лично мы, от перехода к бирюзовой организации, попутно я буду рассказывать про менеджмент и как организованы рабочие процессы:

Во первых, мы избавились от иерархии как таковой, на текущий момент каждый сотрудник компании имеет равные права и возможности и способен влиять на любой процесс при условии что найдет достаточное количество голосов коллег поддерживающих его идею, больше нет отношений начальник-подчиненный, все равны.

Во вторых это полное самоуправление. У нас есть несколько групп администраторов, каждая группа является самостоятельной единицей. Каждая группа вправе принимать любые решения. Например, если я замечу в нашей группе человека который не выполняет свои обязательства, в то время как остальные члены нашей команды работают за него, я могу собрать всех вместе и путем голосования мы решим что нам делать с данным членом команды, попрощаться с ним или дать ему возможность проявить себя в другой роли. Бывают ситуации когда мы просто не может сработаться с конкретным человеком, тогда мы можем также путем голосования исключить его из команды, он не будет уволен, у него останется возможность попроситься в другую команду, или придумать для себя любую другую роль, чем он сможет быть полезен, если другие группы так же не захотят с ним работать и он не найдет чем еще сможет быть полезен организации, то тут конечно исход один, мы прощаемся. Иерархии нет, но есть роли которые сотрудники выбирают самостоятельно, у кого-то хорошо получается общаться с клиентами, кто-то отлично разбирается в базах данных, а кто-то отлично умеет работать с облачными провайдерами, каждый занимается тем что лучше всего получается и что он любит.

В третьих, мотивация сотрудников. Мы отказались от привычной схемы почасовой оплаты и перешли к опциону. Работает это следующим образом, у каждой группы есть некоторое количество проектов за которые они отвечают, со всех платежей клиентов N процентов идет в бюджет группы, возьмем как пример 20 процентов и 3 человека в группе. Группа самостоятельно выбирает какой процент каждый участник группы будет получать, обычно процент зависит от количества ролей которые сотрудник берет на себя и общего количества полезной работы которую он может сделать и делает. В итоге ситуация может выглядеть следующим образом из 20% процентов 2 коллег получат 6%, а один 8%. В итоге мы избавились от ситуации когда человеку было выгодно затягивать задачи и искусственно завышать время. Теперь количество отработанных часов не влияет на оплату которую он получит, важен результат и качество. Бывало доходило до смешного, алерты по проблемам специально не решались должным образом и каждый день приходила новая задача в которой можно было делать тоже самое и проставлять время, до тех пор пока кто-то из тимлидов это не заметит. Сейчас нет никакого смысла так делать, ориентир на качество, проще один раз сделать хорошо и забыть об этом, дополнительно появилось чувство ответственности перед клиентом за качество работ, ведь если клиент будет недоволен качеством работы он может уйти, а это в свою очередь непосредственно скажется на оплате которую получит группа. Если хочется увеличить свой доход тут все также прозрачно, берите новых клиентов и получайте больше, не можете брать новых клиентов из-за большой загрузки - автоматизируйте, избавляйтесь от рутинных задач, берите в команду новых людей, ищите любые другие способы, полная свобода действий. Клиент просит скидку? Решайте сами давать или нет. Нужен отпуск? Согласовали с ребятами из команды даты и вперед, нужен отгул, тоже самое и так далее.

Переходим к коучингу. Помните пример с распределением опциона в группе, теоретически здесь может быть конфликт, ребята могут не договориться кто сколько должен получить и им потребуется кто-то со стороны способный справедливо разрулить ситуацию, на практике таких ситуаций не было, но если такое все же произойдет в работу включаются коучи. В роли коуча обычно выступают самые опытные и уважаемые коллеги, к мнению которых прислушиваются и к которым чаще всего обращаются за помощью в решении любых вопросов как организационных, так и рабочих. Коучи нужны когда команда не справляется с решением вопроса или задачи своими силами, такие ситуации бывают довольно часто и это нормально. Важно отметить что коучи не имеют права указывать что делать, они только дают советы и рекомендации к которым группа может как прислушаться так и нет.

Рассказав про то как организованы наши процессы я хочу рассказать о не менее важной теме, а именно о контроле задач и обеспечении оперативной реакции по задачам.

Прежде чем перейти к методике контроля задач следует сказать что в Southbridge по SLA у нас есть 4 приоритета для задач, и в зависимости от приоритета скорость реакции по задаче будет отличаться.

Задачи с приоритетом “Низкий”, должны выполняться максимум за 5 рабочих дней или быстрее, данные задачи обычно делаются в свободное от остальных задач время. Такие задачи может генерировать как клиент так и компания, и обычно они имеют формат обсуждения, например проработка будущей архитектуры клиента или написание новой роли для Ansible которая в будущем позволит автоматизировать процесс настройки нового сервиса.

Задачи с приоритетом “Нормальный”, должны быть выполнены максимум за 4 часа с момента постановки задачи, таких задач большинство, обычно это рутинные задачи от клиента, просьба добавить нового пользователя, создать площадку под новый сайт, алерт от системы мониторинга по какой-то незначительной проблеме и так далее.

Задачи с приоритетом “Высокий”, должны быть выполнены максимум за 1 час с момента постановки задачи, подобные задачи генерируют как клиенты, когда необходимо что-то срочно сделать, например восстановить файл из бэкапа,  так и система мониторинга, например когда заканчивается место на сервере или zabbix-agent не доступен.

Задачи с приоритетом “Авария”, объяснения не требуют, это любые задачи из любого источника которые требуют немедленного внимания и решения, они должны быть взяты в работу не позднее чем через 15 минут после постановки задачи, по факту внутри нашей команды и других мы используем лимит в 5 минут и в 95% процентов случаев мы успеваем начать работать по задаче не позднее 5 минут после ее появления, и вот как мы этого добились.

Оповещения для администратора, мы используем два канала оповещений, во первых это почта, любой запрос от клиента или алерт от системы мониторинга фиксируются как задача в Redmine, это значит что на любое событие администратор получит уведомление на почту, а чтобы не утонуть в потоке писем используются фильтры по приоритетам, проектам или исполнителям. Во вторых уведомления в Telegram. Они разбиты на группы, у каждой команды своя группа в которую они получают уведомления только по событиям своих проектов, а также общий канал оповещений по всем проектам, он используется во время дежурств. Уведомление состоит из темы задачи, ее приоритета, статуса и ссылки на саму задачу.  Поскольку уведомления приходят в течение секунд после появления задачи это позволяет нашей команде немедленно отреагировать на событие и начать работу. Для задач с приоритетом Авария приходит дополнительное уведомление каждые 5 минут если задача не взята в работу, это помогает не проморгать проблему когда происходит несколько аварий параллельно по нескольким клиентам. Также мы получаем уведомления с заголовком “Напишите статус по задаче”, они приходят когда задача не обновлялась нами в течении некоторого времени, для каждого приоритета установлено свое время, нужны они для того чтобы держать клиента в курсе о ходе выполнения поставленной задачи.

Оперативная реакция, как я говорил раннее у нашей команды как и у любой другой есть отдельный канал для уведомлений, это позволяет нам избавиться от постороннего шума и получать только действительно важные уведомления. Наша команда состоит из 3х человек, это оптимальное на мой взгляд количество, и в любой момент рабочего времени как минимум 2 администратора всегда на связи и смогут отреагировать на любую задачу. Вне рабочее время за уведомлениями и задачами следят дежурные администраторы, здесь стоит отметить что вне рабочие часы дежурные реагируют только на задачи с приоритетом “Авария”.

Такие же уведомления у себя вы можете реализовать с помощью нашего плагина для Redmine, он находится в открытом доступе на GitHub. Ссылку вы можете видеть на слайде.

Переходим к следующей теме.

2. Стандарты в компании. Как научиться быстро решать сложные задач

Единые стандарты конфигурации серверов

Из всех наших стандартов стандарт конфигурации серверов пожалуй является наиболее важным. Данный стандарт позволяет каждой группе обслуживать десятки клиентов с минимальными затратами. Суть его следующая. Каждый сервер настраивается одинаково (здесь я не имею ввиду что абсолютно все серверы имеют одинаковые настройки и параметры) говоря стандарт конфигурации серверов мы имеем ввиду что настройка каждого сервера идет по одному сценарию, используя одни и те же роли системы управления конфигурациями. На выходе каждый сервер имеет одинаковый набор стандартных пакетов и утилит, на каждом сервере одинаково настроен мониторинг и резервное копирование, прописаны наши пользователи, все серверы имеют корректно настроенную PTR запись, hostname, RAID и так далее. Структура каждого сервера идентична любому другому, поэтому когда я перехожу к задачам клиента другой группы мне не нужно тратить много времени на то что бы понять как тут все работает. Я всегда точно знаю что я увижу на сервере когда зайду на него.

Единая структура конфигурационных файлов

Не секрет что конфигурационные файлы можно хранить практически где и как угодно, когда серверов несколько это не проблема, когда их сотни и тысячи то мы получаем хаос. Поэтому мы внедрили еще один стандарт, стандарт конфигурационных файлов и правок на серверах. Суть его в следующем, у каждого сервиса с которым мы работаем, например mysql, nginx или скрипты бэкапов есть конфигурационные файлы, и в зависимости от пакета и версии, пути и имена файлов конфигурации могут отличаться, что бы избежать путаницы и быстрее решать проблемы мы храним конфигурационные файлы в четко заданном месте, всегда и везде одинаково, например для MySQL они всегда будут лежать в одном месте не важно будь это Percona, MariaDB или оригинальный MySQL, на какой бы вы сервер не зашли и какая бы версия СУБД там не стоял конфиг вы найдете именно там, если вы захотите проверить настройки бэкапов они также будут лежать всегда в одном месте, на каждом из тыясяч серверов.

Пример как это выглядит в нашей базе знаний вы можете увидеть на слайде

Подобные правила существуют практически для каждого сервиса и это реально ускоряет процесс работы, поскольку не нужно каждый раз искать где лежит конфиг.

Используйте чек-листы в работе

В работе администратор существует очень много повторяющихся задач, настроить сервер, бэкапы, мониторинг, установить сервис, добавить пользователя, и так далее. Что бы избежать проблем связанных с качеством выполнения задач мы внедрили плагин чек-листов, плагин позволяет заранее подготавливать набор списков с действиями по типовым задачам и позже прикреплять их к задаче, в ручном или автоматическом режиме. Так как многие задачи требуют многих действий данное решение выступает в качестве самоконтроля, и дает нам уверенность что при решении задачи было сделано все необходимое. Например задача по аудиту первичной настройки сервера занимает 18 пунктов, согласитесь подобный объем действий тяжело удержать в голове, а с использование заранее заготовленных списков остается только пройтись по нему, сделать каждый пункт и отметить его как выполненный. 

Аудит проектов. Мы проверяем за собой

Есть два типа аудитов. Первый это когда мы проверяем настройку сервера и всех его сервисов. После того как сервер был настроен основной группой в Redmine ставится задача по аудиту сервера, аудит выполняет администратор из другой группы. Так получается более объективно и качественно, если у администратора появляются вопросы по настройке сервера он пишет все в задачу и возвращает основной группе на доработку.

Второй тип аудита - полный аудит проекта, выполняется периодически для каждого проекта. Данный тип аудита включает в себя проверку: А-записей в DNS, PTR, Slack/Ansible, проверку настройки RAID, мониторинга, бэкапов, автозагрузку и настройку сервисов, актуальность документации по проекту и так далее. В совокупности данные аудиты помогают значительно улучшить качество обслуживания и скорость работы по проектам.

Чего мы не делаем

Это основные запреты которые мы обязаны соблюдать.

1. Мы никогда не правим код в приложении клиента.
2. Никогда не смотрим содержимое баз данных клиента, не меняем структуру и не добавляем индексы самостоятельно, все только руками разработчиков. Исключение - надо проверить целостность таблиц или индексов.
3. Мы не даем доступы так, как просит клиент и не делаем работу так как просит клиент если это не правильно! Это важно! Нужно понимать, что мы отвечаем не только за стабильную работу сервисов и серверов, но и за безопасность. Пытаемся всегда предложить безопасное и правильное решение клиенту. 

В случае аварии, когда нет времени думать о причинах, должен быть точный план действий.

Когда все лежит нет времени часами разбираться что же все таки произошло, что бы ускорить процесс решения проблемы многие из процессов у нас задокументированы. Почти по каждой проблеме можно найти статью в базе знаний либо запись в вики проекта.

Мониторинг не просто сообщает о проблеме, но еще и дает ссылку на пример ее решения в базе знаний. Таким образом в случае проблем всегда есть четкий план действий, куда смотреть, где искать информацию по проблеме и так далее. В случае если проблему не удается решить самостоятельно и по ней нет информации подключаются коучи или другие коллеги которые смогут помочь.

Переходим к следующему разделу

3. Работа с Redmine. Наши разработки, повышающие качество обслуживания и безопасность

Для тех кто не знаком с Redmine. Redmine является open source системой управления проектами написанной на Ruby. Проект активно развивается и разрабатывается с 2006 года, к нему существует огромное количество плагинов покрывающих почти все нужды конечного потребителя.

Мы используем Redmine практически с самого основания компании, и за это время разработали для него достаточно большое количество собственных решений повышающих качество обслуживания клиентов и их безопасность, об этом мы с вами и поговорим.

Начать хочу с описания структуры и процесса взаимодействия с клиентом, как организована структура проектов, ролей пользователей и база знаний.

Проекты

Работа с компаниями-клиентами разбита на проекты (это встроенная функция Redmine). Каждая компания-клиент имеет свой проект, а это значит что у каждого клиента отдельная вики, трекер задач, отчеты, статистика действий и так далее. Клиенты не могут видеть данные из проектов других компаний.

Wiki проектов

Каждый проект имеет собственную Wiki, в которой описывается вся информация, которая с ним связана. У клиентов так же есть доступ к Wiki своего проекта (это зависит от роли пользователя клиента, существуют два основные роли, первая позволяет только ставить и просматривать задачи, запрещая просматривать вики, так как там хранится чувствительная информация, и вторая роль открывает полный доступ к проекту). В Wiki хранятся схемы проектов, информация о наиболее часто встречающихся проблемах характерных для этого проекта, реквизиты доступа к базам данных, FTP аккаунты и прочая информация, прямо или косвенно связанная с проектом.

Учет времени

Система, по которой в задачах Redmine проставляется время, отличается от общепринятой; один час здесь равен единице. Пользоваться таким способом простановки времени не удобно.

Другой путь - писать время в привычных нам часах и минутах, но указывать непосредственно после них единицы измерения. Так как указано на слайде

Типы задач

Есть два типа задач.

Первый. Задачи создаваемые участниками проекта

Задачи создаваемые участниками проекта - это задачи, которые были созданы клиентами или сотрудниками компании. В таких задачах могут содержаться просьбы клиента выполнить какие-либо настройки на его серверах, установить необходимое для работы ПО, или просто ответить на интересующие его вопросы. Мы так же можем создавать задачи, и попросить в них выполнить клиента какие-либо действия.

Второй тип, это задачи создаваемые автоматически

Задачи создаваемые системами мониторинга. Это могут быть задачи, говорящие о высокой нагрузке на каком-либо из хостов, о том, что на хосте клиента заканчивается место, о том, что какой-либо сервис завершился с ошибкой и был перезапущен, или о многом другом. Автоматически, так же, создаются некоторые внутренние задачи компании, например задачи, уведомляющие нас о дежурствах.

Правила работы с задачами

Перед началом работы с задачей важно понять суть проблемы. Если суть проблемы не ясна - следует обратиться к Wiki проекта, затем, если информация в Wiki не помогла, следует задать вопрос более опытному коллеге, либо в общем чате. Уточняющий ответ клиенту следует задавать только в том случае, если никто не сможет объяснить вам суть проблемы. При общении с клиентом следует понимать то, что клиент может не осознавать тот факт, что вы не владеете в полной мере той информацией, которой владеет он. Поздоровайтесь, вежливо попросите клиента подробнее описать интересующие вас детали, постарайтесь чтобы ваш вопрос был понятен клиенту, другими словами, постарайтесь поставить себя на место клиента.

Наши разработки, повышающие качество обслуживания и безопасность

Первое о чем стоит упомянуть это плагин под названием Redmine Wiki Encryptor

В wiki каждого проекта как я уже говорил раннее мы храним как документацию так и достаточно чувствительные данные, такие как доступ к хостинг провайдерам, доступы к серверам и так далее и что бы не хранить эти данный в открытом виде в базе данных мы написали собственный плагин который выполняет шифрование всех данных которые заносятся wiki, с плагином вы можете ознакомиться на GitHub

Функция заморозки задач (дата и время). Помогает не запоминать и планировать работу.

Часто бывают ситуацию когда задача не может быть решена и закрыта сразу после ее постановки, иногда необходимо достаточно продолжительно время. Как пример мы восстановили резервное копирование после сбоя и нам необходимо через несколько дней проверить что все работает корректно, для этого можно заморозить задачу и установить время повторного открытия например через 2 дня в 11 часов, через два дня в 11 часов задача будет открыта повторно и мы не забудем что нам нужно было проверить работу бэкапов. Естественно можно не замораживать задачи, но тогда будет большой список открытых задач что создает беспорядок и чувство завала в команде

Задачи-напоминания (Redmine Recurring Tasks).

Когда замораживать неудобно, мы планируем расписание из задачи-шаблона, по расписанию создаются задачи, например, проводить аудит производительности сайта каждый первый день месяца в 10-45 МСК. По этому расписанию каждый месяц будет создаваться новая задача с заданным описанием в заданное время

Двухфакторная авторизация в Redmine. Безопасность и возможности плагина

Поскольку в Redmine находится очень много чувствительной информации мы постоянно работаем над улучшением его безопасности. Для дополнительного обеспечения безопасности мы разработали плагин, который на выбор предоставляет три способа дополнительной авторизации, совместно с паролем можно использовать дополнительную авторизацию: через SMS, Telegram или Google. Ознакомиться с плагином вы также можете на GitHub

Плагин SLA.

Последний плагин который я упомяну составляет для нас ежедневные, еженедельные и ежемесячные отчёты о затраченном времени по проектам и статусу соблюдения SLA. Пример вы можете видеть на слайде, а исходный код также как и прежде можно получить на GitHub.

Переходим к последней главе нашей сегодняшней лекции, называется она:

4. Правила и стандарты работы с системами управления конфигурацией (Ansible / Slack)

Структура Slack

slack - это система управления конфигурацией, которая работает по простейшему принципу взять файлы из центрального репозитория и поместить их на сервер и выполнить какие-то действия. По сути данный проект является мертвым и не развивается примерно с 2008 года. До недавних пор это был единственный наш инструмент управления конфигурациями серверов, и он отлично справлялся и справляется до сих пор с этой задачей. У него есть несколько основных преимуществ перед современным средствами управления конфигурацией. Во первых это простота, во вторых скорость работы, то на что ансибл потратит 10 минут, слак сделает за минуту или даже меньше.

На слайде вы можете видеть что происходит, когда slack запускается на клиенте. (На центральном сервере нет специальных демонов - просто дерево файлов, доступных через rsync.)

1. Во первых он получает список ролей для хоста запустившего слак
2. Во вторых копирует файлы и скрипты для всех ролей сервера в локальный кэш
3. Для каждой роли он выполняет:
    * Формирование файлов из локального кэша
    * Формирование скриптов из локального кэша
    * Запуск 'preinstall' скрипта.
    * Запуск 'fixfiles' скрипта.
    * Копирует файлы в их финальные локации из локального кэша
    * И запускает 'postinstall' скрипт.

Имена ролей должны начинаться с буквы и должны ограничиваться «нормальными» символами это Буквы, цифры, тире и символы подчеркивания. 

Каждый файл должен модифицироваться только одной ролью. Скрипты разных ролей могут вносить изменения в один и тот же файл, но в этом случае необходимо проявлять осторожность, чтобы гарантировать, что изменения взаимо совместимы.

Конечно лучше стараться чтобы роли были полностью независимыми, так что бы порядок обработки не имел значения. Тем не менее роли обрабатываются в порядке, указанном в файле ролей. И это можно использовать когда необходимо.

С каждой ролью связаны три сценария: preinstall, fixfiles и postinstall.

Preinstall выполняет действия перед копированием файлов

Скрипт fixfiles - как понятно из названия, занимается выставлением прав и владельца на файлы и каталоги.

Postinstall выполняет определенные в нем действия после того как файлы раскладываются по своим местам

По сути слак это обвязка над rsync.

Команда rsync используется для четырех целей slack.

Во первых для копирования файла ролей

Во вторых для копирования удаленных файлов в локальный кеш

В третьих для копирования файлов из локального кэша в промежуточное дерево.

И в четвертых для копирования файлов из промежуточного дерева в конечное место назначения.

Это в общем то все что касается работы слак, как видите все просто, конфиги сервисов берутся из центрального репозитория, и скриптами на bash выполняются дополнительные операции.

Теперь поговорим немного о том как вносить правки, разом для всех проектов и отдельно для каждого. Что выполнить какую-то команду на всех серверах сразу, достаточно обновить базовую роль которая используется абсолютно на каждом сервере. Все файлы и роли слак мы храним в гит, и для того что бы внести правки в любую роль нужно данный репозиторий выкачать к себе, выкачиваем, делаем необходимые правки и пушим обратно в репозиторий. Через несколько минут все серверы получат обновленные файлы и скрипты.

Для того что бы внести правки по конкретному хосту необходимо внутри роли создать подкаталог по конкретному хосту, например так как указано на слайде. Тогда хост получит любые другие файлы и настройки которые мы укажем

Переходим к Ansible

Ansible — опенсорсное программное решение для удаленного управления конфигурациями, разработанное Майклом Де Хаанном в 2012 году. Название продукта взято из научно-фантастической литературы: в романах американской писательницы Урсулы Ле Гуин ансиблом называется устройство для оперативной космической связи.

Ansible берет на себя всю работу по приведению удаленных серверов в необходимое состояние. Администратору необходимо лишь описать, как достичь этого состояния с помощью так называемых сценариев (playbooks; это аналог рецептов в Chef). Такая технология позволяет очень быстро осуществлять переконфигурирование системы: достаточно всего лишь добавить несколько новых строк в сценарий.

Почему Ansible?

Преимущества Ansible по сравнению с другими аналогичными решениями (здесь в первую очередь следует назвать такие продукты, как Puppet, Chef и Salt) заключаются в следующем:

* на управляемые узлы не нужно устанавливать никакого дополнительного ПО, всё работает через голый SSH (в случае необходимости дополнительные модули можно взять из официального репозитория);
* код программы, написанн на Python, очень прост; при необходимости написание дополнительных модулей не составляет особого труда;
* язык, на котором пишутся сценарии, также предельно прост YAML;
* низкий порог вхождения: обучиться работе с Ansible можно за очень короткое время;
* документация к продукту написана очень подробно и вместе с тем — просто и понятно
* Ansible может работать не только в режиме push, но и pull;
* имеется возможность последовательного обновления состояния узлов (rolling update).

Установка

Требования для установки Ansible минимальны. На машине с которой производится управление должен быть установлен Python версии 2.6 или выше. На управляемых узлах должен быть установлен только Python версии не ниже 2.4, но он, как правило, по умолчанию включен в состав большинства дистрибутивов linux. Винда не поддерживается.

Устанавливается ansible одной командой, для большинства самый популярных дистрибутивов есть официальные репозитории из которых можно скачать самые свежие версии Ansible.

Группы серверов

Список групп серверов, которыми нужно управлять, Ansible может получать двумя основными способами:

1. Во первых из специального текстового файла (далее этот вариант мы рассмотрим более подробно);
2. Во вторых с помощью внешнего скрипта, возвращающего нужный нам список серверов. В официальном github-репозитории есть готовые скрипты для получения списка из Digital Ocean, Amazon, Linode, OpenStack, Zabbix и многих других.

Файл hosts

Дефолтное расположение файла — /etc/ansible/hosts, но оно может также быть задано переменной окружения $ANSIBLE_HOSTS или параметром -i при запуске ansible и ansible-playbook. Содержимое этого файла может выглядеть, примерно как указано на слайде

Помимо списка управляемых узлов, в файле hosts могут быть указаны и другие сведения, необходимые для работы: номера портов для подключения по SSH, способ подключения, пароль для подключения по SSH, имя пользователя, объединения групп и так далее. В некоторых случаях — в частности, при работе с большими и сложными конфигурациями, — различные параметры можно выносить в отдельные файлы и каталоги.

Информация об узлах (Факты)

Перед внесением изменений Ansible подключается к управляемым узлам и собирает информацию о них: о сетевых интерфейсах и их состоянии, об установленной операционной системе и тому подобное. Он может делать это как с помощью собственного модуля, так и с помощью сторонних инструментов.

Переменные

Во время деплоя, как правило, требуется не только установить какое-либо приложение, но и настроить его в соответствии с определенными параметрами на основании принадлежности к группе серверов или индивидуально. Загромождать файл hosts будет не очень красиво, поэтому разработчики Ansible пошли следующим путём:

* файлы с переменными групп хранятся в директории “group_vars/имя_группы”;
* с переменными хостов в директории “hosts_vars/имя_хоста”;
* с переменными роли в директории “имя_роли/vars/имя_задачи.yml”;

Помимо пользовательских переменных можно (и даже нужно) использовать факты, собранные ansible перед выполнением сценариев и отдельных задач.

Модули Ansible

В состав Ansible входит огромное количество модулей для развёртывания, контроля и управления различными компонентами, которые можно условно разделить на группы указанные на слайде. На самом деле в стандартной поставке можно найти модуль практически для чего угодно. Если вам нужно что-то совсем специфичное вы можете поискать уже готовый модуль в интернете или написать свой.

Cценарии (playbooks или плейбуки)

Все сценарии в Ansible пишутся на YAML. Это — человекочитаемый формат сериализованных данных, гораздо более простой, чем XML или JSON.

Чтобы выполнить сценарий используется команда ansible-playbook со следующим сиснтаксисом

ansible-playbook <имя_файла_сценария.yml> ... [и остальные параметры]

В начале сценария обязательно должна присутствовать последовательность символов из трех минусов «- - -» (так в YAML обозначается начало документа). Перед каждым новым разделом списка ставится минус ( – )

Основными параметрами/группами простого сценария являются:

* hosts — в нем указываются управляемые узлы или группы узлов, к которым нужно применить изменения;
* tasks — здесь описывается состояние, в которое необходимо привести управляемый узел, альтернативой этому могут служить роли;

Также в сценарии перед непосредственным описанием задач могут быть указаны следующие параметры или группы параметров:

* gather_facts — собирать или нет информацию о хостах перед выполнением задач, по умолчанию — да;
* vars — в нем указываются различные переменные, которые будут использованы при выполнении сценария;
* connection — можно указать метод соединения с хостами: чистый ssh, chroot, jail и так далее;
* become — после установления соединения выполнять задачу с привилегиями другого пользователя, по умолчанию другой пользователь — root;

Шаблонизация

В Ansbile используется шаблонизатор Jinja2

В приведённом примере мы подставляем в шаблон следующие значения:

из заранее собранных фактов о хосте:

* ansible_default_ipv4.address — основной IPv4-адрес хоста;
* ansible_default_ipv6.address — основной IPv6-адрес хоста;
* ansible_hostname — имя хоста (результат выполнения команды hostname).

inventory_hostname — имя хоста в инвентарном файле;
пароль пользователя из внешнего источника данных (в данном случае файл)

Обработку шаблонов и, в данном случае, генерацию конфигурационного файла выполняет модуль template; он же может задать необходимые права доступа и изменить владельца/группу

Обратим внимание на то, что файл шаблона и файл с паролем пользователя базы данных находятся на машине управления, а результатом будет файл на удалённом узле.

Обработчики событий (Handlers)

Ansible не просто выполняет задачи в указанном порядке, но и проверяет их состояние на наличие изменений. Если при выполнении сценария требовалось, например, добавить строку в конфигурационный файл, и в результате выполнения он изменился (необходимой строки действительно не было), то Ansible может выполнить специальную задачу, описанную как обработчик события или (handler). Если при выполнении строка уже была в конфигурационном файле, то обработчик выполнен не будет. Обработчики событий описываются в конце сценария; в описании задачи они указываются через параметр notify.
Пример вы можете видеть на слайде

Роли

Ролью называется типовой набор переменных и задач, назначаемых для одного или нескольких серверов. Если вам нужно применить к серверу или группе серверов типовой набор операций, вам достаточно просто назначить ему роль. Предварительно в проекте каталоге проекта должна быть создана соответствующая структура. В плейбуках роли назначаются так как указано на слайде