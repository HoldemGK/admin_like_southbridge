Добрый день. Мы поговорим о вещи, которая кардинально изменила мир. 
По крайней мере в области создания программного обеспечения и особенно для open source (по с открытым исходным кодом).

я говорю о системе контроля версий Git. 

В современном мире уметь пользоваться системой контроля версий обязан каждый сисадмин и разработчик. 
По результатам лекции вы получите основные навыки работы с git, научитесь работать в команде, создавать и организовывать процесс коллективной разработки.
Будете понимать как устроен гит, какие у него есть сильные и слабые стороны и как применить это знания для достижения ваших целей.

Я вам расскажу про:
- историю создания систем контроля версий
- базовые команды git 
- основные приемы работы с git в распределенной среде
- систему управления репозиториями gitlab - ее установку, обслуживание и настройку прав доступа

Что такое система контроля версий, почему у нее такое странное название, и как все начиналось ?

Когда слышишь словосочетание "система контроля версий", то чувствуешь какую-то незаконченность и появляется резонный вопрос - контроль версий чего именно ?
На разных этапах развития подобных систем это были отдельные файлы, потом целиком код проекта, и наконец дерево развития проекта... - в общем случае это какая-то информация
и можно было бы сказать, "систем контроля версий информации", что тоже звучит не очень благозвучно.

"Система контроля версий" является подстрочным переводом термина Version control system, который на английском звучит вполне закончено, а по русски немного странно.
Но такой перевод широко используется и поэтому остается только принять и запомнить ;)

Давным-давно, когда компьютеры перестали быть большими, у них появились монитор, клавиатура и дискетка
программисты перестали выкалывать дырочки в перфокартах и начали писать программы, набивая их на клавиатуре, и сохраняя код на дискете,

Имея возможность сохранять код на дискетку, сразу же стали сохранять различные версии кода, помечая их отметкой времени и комментарием.
И вот эти архивы, содержащие код на различных стадиях разработки и стали первым подобием системы контроля версий.
Естественно создавать архивы вручную было неудобно, также хотелось хранить не полные архивы кода, а только измененные части, иметь возможность посмотреть что было изменено в коде, начиная с определенной версии.  
Для решения этих задач были созданы локальные системы контроля версий, одной из самых популярных была RCS, эта система хранила на диске набор патчей, последовательно применяя которые, позволяла воссоздать состояние каждого файла для любой из версий, сохраненных в системе.

Следующая серьёзная проблема, с которой сталкиваются люди, — это необходимость взаимодействовать с другими разработчиками. Для того, чтобы разобраться с ней, были разработаны централизованные системы контроля версий (ЦСКВ). Такие системы, как: CVS, Subversion и Perforce, имеют единственный сервер, содержащий все версии файлов, и некоторое количество клиентов, которые получают файлы из этого централизованного хранилища. Применение ЦСКВ являлось стандартом на протяжении многих лет.

Такой подход имеет множество преимуществ, особенно перед локальными СКВ. Например, все разработчики проекта в определённой степени знают, чем занимается каждый из них. Администраторы имеют полный контроль над тем, кто и что может делать, и гораздо проще администрировать ЦСКВ, чем оперировать локальными базами данных на каждом клиенте.

Несмотря на это, данный подход тоже имеет серьёзные минусы. Самый очевидный минус — это единая точка отказа, представленная централизованным сервером.

Для решения этой проблемы приудмали децентрализованные системы контроля версий.  В ДСКВ (таких как Git, Mercurial, Bazaar или Darcs), клиенты не просто скачивают снимок всех файлов (состояние файлов на определённый момент времени): они полностью копируют репозиторий. Каждая копия репозитория является полным бэкапом всех данных. Более того, многие ДСКВ могут одновременно взаимодействовать с несколькими удалёнными репозиториями - использование этой возможности стало одной из основных причин популярности гитхаба.

Автором первой версии Git является Линус Торвальдс, да, тот самый, кто придумал linux. При разработке ядра линукс с 1991 по 2002 гг. изменения между разработчиками передавались в виде патчей и архивов, в 2002 году проект начал использовать пропиеритарную децентрализованную СКВ Bitkeeper, но в 2005 медлу сообществом разработчиков ядра Lunux и владельцем Bitkeeper возникли разногласия, дальнейшее бесплатное использование оказалось невозможным. И Линус решил написать свою собственную систему контроля версий. 3 апреля 2005 г. началась разработка и уже 7 апреля появилась первая рабочая версия. а 16 июня код Linux был переведен на git.
Кстати, существует много легенд, почему систему назвали именно git:- вставить риторический вопрос.
- начиная, от случайных трех букв, которое легко произносить и которое не похожи на существующие команды в линукс
- заканчивая саркастическим высказыванием Торвальдса: "Я эгоистичный ублюдок, и поэтому называю все свои проекты в честь себя. Сначала Linux, теперь git" (git на английском сленге означает - "мерзавец")

Цели которые преследовала новая система:
- скорость
- простая архитектура
- хорошая поддержка нелинейной разработки
- полная децентрализация
- возможность эффективного управления большими проектами

Судя по тому, что git является стандартом defacto все эти цели успешно достигнуты.

Давайте рассмотрим особенности git, которые помогли ему достигнуть этих целей:
- большинство СКВ хранят первоначальное состояние файла и набор патчей, для каждой из версий. GIT, для каждой из версий, хранит полный снимок содержимого файлов.
  Естественно используются алгоримты дедупликации и если файл не был изменен, то несколько снимков будут ссылатся на одно и то же содержимое файла.
  Подобный подход кажется странным и не логичным, но именно он позволяет GIT автоматизировать и ускорить процессы ветвления кода и нелинейной разработки
- Так как гит копирует к себе репозиторий, то и почти все процессы работы с ним выполняются локально.
- Для обеспечения целостности данных в гит для всего вычисляются хеш-суммы, все обращения к объектам происходят по этим хеш-суммам, в гите хеши используются везде.
- Git только добавляет данные. Есть небольшие возможности по изменению последнего сделанного коммита. Очень сложно что-либо аккуратно удалить не из последнего коммита, а если этот коммит уже отправили на центральный сервер и его оттуда забрали коллеги, то точно не стоит так делать. Поэтому всегда надо очень аккуратно подходить к добавлению файлов в коммиты. - Самая актуальная проблема при освоении гита - это добавление в репозиторий архива БД, или пары тысяч картинок, после чего репозиторий распухает до пары гигабайт размером.
- и наконец главная особенность гит, которую надо хорошо понимать, чтобы успешно им пользоваться. Называется она - состояния файла.
  Файл может находится в трех состояниях - зафискированный (commited), измененный (modified) и подготовленный (staged).
  Зафиксированные - это те файлы, которые сохранены в системе.
  Измененные - соответсвенно, файлы которые мы изменили, и они еще не сохранены
  Подготовленные - это измененные файлы, отмеченные для включения в следующий коммит
Более подробно зачем нужны эти состояния и как с ними работать мы рассмотрим чуть позже.

А пока перейдем к практической части. Установка git простая, но есть свои особенности ;)
Если на чистой Centos набрать yum install git, то установится достаточно старая версия 1.8, учитывая что недавно выпустили 2.19...
Мы в своей работе пользуемся собственным репозиторием, я примерно год назад собрал и положил туда git версии 2.12
В Epel почему-то нет git, зато он есть в https://ius.io на сегодняшний момент там лежит версия 2.16

Так что сначала выбираем нужный репозиторий, и устанавливаем git
Следующим шагом, согласно правилам хорошего тона, следует рассказать Git как вас зовут и какой у вас email, эти настройки в будущем помогут вашим коллегам найти того, кто все сломал, так как гит будет автоматически добавлять эту информацию в каждый коммит.

git config --global user.name "Your Name"
git config --global user.email "you@yournet.kz"

Так же, если вдруг когда нибудь понадобится пушить по протоколу http можно увеличиться размер буфферов.
git config --global http.postBuffer 524288000

После настройки можно приступать собственно к работе с GIT

Сначала создадим репозиторий командой
git init
Это команда создаст в текущем рабочем каталоге подкаталог .git, в котором содержаться все файлы репозитория.
Теперь надо указать git какие именно файлы необходимо отслеживать, делается это командой git add
git add . - добавили все файлы в текущем каталоге и подкаталогах
git add *.py - добавили все файлы с расширением py
git add README.md - добавили один файл 

и после этого занесли их состояние в репозиторий

git commit -m "init"

вот такого набора команд вполне достаточно, чтобы работать с гитом в стиле локального репозитория.
Теперь самое время вернутся к трем состояниям файла в гите и узнать, что на самом деле этих состояний четыре.

слайд.

На слайде мы видим жизненный цикл состояний файлов.
Самое левое состояние - Untracked - файлы которые не отслеживаются гит.
командой git add мы переносим эти файлы из Untracked в Staged - т.е. говорим гиту, что планируем добавить эти файлы в репозиторий.
Все остальные файлы находятся в состоянии Unmodified - т.е. неизмененных. если какой либо файл отредактировать, то его состояние станет Modified
и обратите внимание - что Staged И Modified - Это разные состояния. Чтобы модифицированные файлы попали в коммит им надо сменить состояние на Staged
Смена состояния делается командой git add, да точно такой же командой как и добавление нового файла.
Это важно понимать - git add добавляет файлы в staged, а не в репозиторий - 
а вот уже из Staged в репозиторий снимок всех файлов добавляется командой git commit

Физически информация о том какие файлы мы перенесли в состяние Staged находится в файле .git/index

Естественно файл можно убрать из отслеживаемых командой git rm, вот тут на картинке есть некоторая неточность - на самом деле git rm удалит файл из рабочего каталога
и поместит информацию о том, что файл был удален в staged. соотвественно, чтобы информация об удалении файла попала в репозиторий надо сделать git commit.

Посмотреть информацию о том, какие файлы модифицированы, а какие уже добавлены в staged можно командой 
git status
Естественно, после того как мы внесли исправления в десяток файлов и хотим сохранить наши изменения, очень неудобно набирать git status, запоминать список файлов, потом каждому из них делать git add, поэтому обычно для коммита используют вот такую команду
git commit -a - опция -a говорит, что перед коммитом надо добавить в staged все измененные и удаленные файлы.
новые файлы необходимо добавлять вручную, с помощью git add

Когда вы делаете commit git, во первых рассчитывает его хеш-сумму, по которой в будущем к этому коммиту можно будет обратится, а во вторых добавить в него хеш предыдущего, родительского коммита. Таким образом формируется история изменений.
посмотреть эту историю можно командой git log
git log -p покажет также что именно и в каких файлах поменялось в каждом коммите. Внимание - мы же помним, что гит хранит содержимое файлов, а не их изменения, так что вывод  git log -p - это вывод команды diff между двумя коммитами, а не вывод содержимого коммита.

Еще раз - Коммит - это основная сущность гит, каждый коммит содержит снимок состояния нашего рабочего каталога. 
И в любой момент можно переключится на это состояние. Переключение осуществляется командой git checkout <hash коммита>

Мы теперь умеем создавать коммиты и самое время переходить к ветвлению.
Ветвление - это возможность вести разрабтку несколькими параллельными и независимыми потоками, когда можно легко и быстро переключать свой рабочий каталог между разными ветками, а по окончании работ все свои изменения можно будет легко перенести в основной поток разработки.

Что же такое ветка в гит - на самом деле это именованный указатель на коммит. Имя основной ветки по умолчанию в GIT - master. На самом деле ветка мастер автоматически создается при инициализации репозитория командой git init и большинство людей ее не меняют. Когда вы делаете коммит, git автоматически меняет указатель вашей текущей ветки так, чтобы он указывал на ваш коммит (на картинке это выглядит, как будто он его сдвинул вперед).
Информация о том, какая ветка является вашей текущей, а также какой коммит развернут в вашем рабочем каталоге хранится в специальном указателе HEAD

Новая ветка создается командой git branch <имя ветки> - по факту это создание нового именованного указателя - очень просто и быстро.
Ситуация на слайде.
Чтобы начать разработку в новой ветке надо на нее переключится, делается это уже знакомой командой git checkout <название ветки> 
вместо хеша коммита мы указываем название ветки, HEAD начинает указывать на новую ветку, рабочий каталог приводится к состоянию из коммита на который указывает ветка.

Самое время перейти наконец к технологиям работы с гит - Основы ветвления и слияния.

Давайте рассмотрим простой пример рабочего процесса, который может быть полезен в любом проекте. Обычно работа построена так:

Вы работаете над проектом. Вы создаете ветку для нового функционала, который пишете.
Вы работаете в этой ветке.

В какой то момент вы получаете сообщение, что обнаружена критическая ошибка, требующая скорейшего исправления.
Ваши действия:

Переключиться назад на основную ветку.
Создать ветку для добавления исправления.
После тестирования слить ветку содержащую исправление с основной веткой.

Переключиться назад в ту ветку где вы пишите функционал и продолжить работать.
Серия слайдов:
линия коммитов

git checkout -b iss53
ee readme 
git commit -a -m "new switch"

git checkout master
git checkout -b hotfix
ee driver.c
git commit -a -m "hotfix - leak memory"


git checkout master
git merge hotfix
Updating f42c576..3a0874c
Fast-forward - так как от мастера до хотфикса нет никаких разветвлений, то гит просто перемещает указатель мастера на тот же коммит, на какой указывает хотфикс.
это называется Fast-forward

git branch -d hotfix
git checkout iss53
git commit -a -m 'fix errors'

git checkout master
Switched to branch 'master'
git merge iss53
Merge made by the 'recursive' strategy.

Гит выполняет простое трехстороннее слияние и создает новый коммит специального типа, у которого два родителя.
Я не знаю почему в документации это называли простыми трехсторонним слияеним - мне кажется, что тут задействована магия и исскуственный интеллект.
Правда иногда, когда встречаются фрагменты в файлах, которые были изменены в обоих ветках по сравнению с базовой, гит не может автоматически выбрать какой из двух фрагментов правильный и предлагает вам сделать это самостоятельно.
Удбнее делать это через веб-интерфейс гитлаба.

Все что мы делали до сих пор - это работали с локальным репозиторием. но ведь гит - это децентрализованная система, поэтому пора научится делится своими гениальными наработками с коллегами и со всем миром.

Как правило изначально мы присоединяемся к разработке какого либо проекта, поэтому для начала нам надо склонировать себе копию репозитория 
делается это командой git clone

git clone https://github.com/git/git

Также можно добавить удаленный репозиторий к нашему локальному командой git remote add название url

git init
git remote add upstream git@gitlab.southbridge.ru:slurm/red_slurm.git
Подключаем удаленный репозиторий red_slurm и назначаем ему псевдоним upstream

Доступ к удаленному репозиторию можно осуществлять по протоколу HTTP или SSH
Обычно по протоколу HTTP клонируются общедоступные репозитории, в которые вы не планируете пушить свой код.

Как правило для авторизации при пуше по протоколу HTTP используется Basic-auth, плюс надо увеличить размеры postbuffer (что мы делали при первоначально настройке гит-клитента)

Но более правильным и удобным является доступ к удаленному репозиторию по протоколу ssh. Как видно из url для доступа к репозиторию гит устанавливает ssh соединение с сервером под пользователем git. Авторизация проходит с помощью ключей.

Теперь начинается очень важная часть, которая поможет вам понять логику работы с удаленным сервером.
что у нас хранится в репозитории ? Правильно. коммиты.
- когда мы получаем информацию с сервера, то получаем новые коммиты и информацию о том на какие коммиты указывают ветки на сервере
- информация о ветках, которые есть на удаленном сервере сохраняется в отдельном месте и все ветки имеют название вида
  remotes/origin/название ветки - здесь слово origin это псевдоним репозитория, который используется по умолчанию
  информация об удаленных ветках доступна нам только для чтения, напрямую менять мы их не можем.
- для того чтобы увидеть в своем рабочем каталоге новые данные с сервера необходимо объединить ветку с сервера с локальной веткой

Давайте рассмотри последовотельность команд гита, которые позволяют получить новые данные с сервера, а потом покажем команды гит, которые позволяют упростить работу:

git init - создали пустой репо
git remote add origin git@gitlab.southbridge.ru:slurm/red_slurm.git  - подключили репозиторий
git fetch origin - получили коммиты и ветки с сервера
git branch -av - диагностика посмотрели список веток, видим что в наличии только ветки в удаленном репозитории, в рабочем каталоге пусто
git checkout -b master origin/master  - создаем локальную ветку мастер, которая будет связана с веткой мастер на удаленном репозитории
git branch -avv - диагностика видим локальную ветку мастер, ключ -vv позволяет увидеть, что она связана с веткой origin/master

У гита есть специальная команда, которая сразу делает все, что мы тут перечислили:
git clone origin git@gitlab.southbridge.ru:slurm/red_slurm.git - создает репозиторий, скачивает в него данные, создает ветку мастер и связывает ее с веткой на сервере

Естественно все пользуются одной командой git clone, но знать и понимать что именно она делает жизненно необходимо.

Следующий типовой шаг - получение данных с сервера:

git fetch origin - получили
git checkout master - переключились на локальный мастер 
git merge origin/master - объединили коммиты из удаленной ветки origin/master с нашей локальной веткой.
Если мы не вносили никаких изменений - то объединение пройдет по стратегии FastForward - просто переместим локальную ветку на тот же коммит, что и  удаленная
Если что-то меняли git выполнить простую трехстороннюю процедуру слияния, и создаст новый коммит, в котором будут все наши изменения, и изменения полученные с сервера.

Специальная команда, которая все это делает называется 
git pull - она выкачивает новые коммиты с сервера и объединяет текущую локальную ветку со связанной удаленной веткой. помните как мы раньше создавали локальную ветку ?

После того как мы насоздавали новый коммитов надо отправить их на сервер

Делается это командой 
git push - даннай команда отправляет все коммиты текущей ветки на сервер. Если гит не сможет сообразить что и куда вы хотели отправить он выдаст вам подсказку,
какие ключи надо добавить к команде, чтобы он точно послал данные куда надо.

До этого мы работали с веткой мастер, давайте теперь создадим новые ветки:

git checkout -b bname origin/bname - Создаем локальную ветку bname и связываем ее с удаленной веткой bname (названия веток могут не совпадать, но лучше так не делать)
git checkout bname - переключаемся на локальную ветку bname - Если у вас еще нет такой ветки, но есть один удаленный сервер, на котором эта ветка есть, то выполнится команда выше - т.е. создастья локальная ветка, которая будет связана с удаленной. Естественно все пользуются этой короткой версией, и когда приходится подключать больше одного удаленного репозитория - начинаются вопросы, а почему не работает.

Если ветки с таким названием нет в  локальных и удаленных - то git покажет ошибку. Но можно просто создать новую ветку

git branch bname - создали ветку
git checkout bname - переключились на нее

то же самое одной командой
git checkout -b bname - создали и сразу переключились

если запушить изменения в этой ветке командой git push - гит выдаст сообщение, что текущая ветка не имеет апстрима, и предположит что вы хотите запушить на удаленный сервер orign

> git push

fatal: The current branch bond has no upstream branch.
To push the current branch and set the remote as upstream, use

    git push --set-upstream origin bname

> git push -u origin bname - соглашаемся и пушим (-u короткая форма записи)

Маленькое лирическое отступление - пушить напрямую в мастер считается дурным тоном. 
Стандартная процедура выглядит следующим образом - создаем новую ветку от текущего мастера, решаем в ней задачу, и создаем MergeRequest, который предлагаем проверить и одобрить человеку, отвественному за проект в целом.

Но дело в том, что во первых сам по себе гит никаких MergeRequest не умеет, и так же не позволяет задать разные права на репозиторий.
Для решения этих проблем, а так же для решения множества прочих задач, которые превращают систему контроля версия в мощную среду совместной разработки разработали такие решения как BitBucket, GitHub, GitLab.
Gitlab выделяется тем, что его можно поставить на свой сервер и получить свою личную, приватную систему. Он бесплатный. Его бесплатной версии хватает, чтобы комфортно работать сотне разработчиков. Если вдруг потребуется больше - то существуют enterprise решения, которые масштабируются на множество серверов, это позволяет оставаться всем в комфортной и привычно среде, когда компания вырастет настолько, что ей перестанет хватать бесплатной версии.

Процесс установки гитлаба очень простой. Я рекомендую ставить его на отдельную виртуалку. выделять как минимум 16 гигабайт памяти и быстрые SSD диски. (в минимальных требования указано 4Gb озу)

Давайте поставим гитлаб.
Вбиваем в гугль gitlab install, первая ссылка на сайт гитлаба
https://about.gitlab.com/installation/

Читаем рекомендации и естественно будем использовать omnibus package - специальный пакет, который автоматически устанавливает гитлаб и все необходимые ему программы
(а их штук 15 уже кажется)

ищем свой дистрибутив - Centos7, щелкаем, нам показывают какие зависимости необходимо установить:
curl openssh-server и утилиты для питона
далее включим sshd и откроем в фаерволле доступ по протоколу http, не забудьте также открыть доступ по https
Плюс устанавливаем и включаем постфик, чтобы гитлаб мог слать нам письма с отчетом что он там натворил.

Ваши учебные сервера настроены нашей системой первичной настройки, которая уже поставила все нужное, выключила firewalld, так что все эти действия выполнять не надо.

Скачиваем и запускаем скрипт, который установит репозиторий гитлаба:

curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-сe/script.rpm.sh | sudo bash

Обратите на лукавство гитлаба - по умолчанию они предлагают скачать скрипт, который установит репозиторий для gitlab-ee - Enterprise версию гитлаба, которая работает 30 дней, а потом просит денег.
Меняем gitlab-ee на gitlab-ce и ставим полностью бесплатную версию:

Указываем при установке переменную окружения и ждем минут 5, пока все отработает
EXTERNAL_URL="http://gitlab.r01.slurm.io" yum install -y gitlab-сe

сценарии установки все настроят, самостоятельно выпишут сертификат у letsencrypt и вам останется только зайти по адресу, который вы указали
и задать пароль администратора.
После чего можно зайти в веб-интерфейс гитлаба (пользователь root, пароль тот, который вы задали) и начать работу:
создавать группы, проекты и пользователей...

Показываем на экране веб-интерфейс. где создать группу, как проект, как пользователя.

Переходим на страничку пользователя - добавляем свой публичный ключ.

Переходим в проект - показываем подсказку, обращаем внимание на знакомы команды гита.

Создаем проект. пушим коммит. 

В качестве защиты от бесконтрольных изменений в гитлабе существует концепция защищенных веток (Protected Branch). По умолчанию защищенной является ветка в мастер.
В защищенную ветку разрешенно добавлять коммиты только привелигированным пользователям. Пользователи в гитлабе имеют 5 уровней привилегий

Guest - могут только создавать Issues
Reporter - могут смотреть код
Developer - могут создавать новые ветки и мерджреквесты
Mantainer - могут принимать мерджреквесты, коммитить в защищенные ветки
Owner - могут назначать привилегии

Как я уже говорил стандартный цикл разработки выглядит следующим образом:
Разработчик имеет привилегии Developer, при разработке нового функционала или для исправления ошибки он создает новую ветку в которой работает.
При наличии настроеного процесса CI/CD для него создается окружение в котором он тестирует результаты своей работы.

По завершении работ, разработчик через веб-интерфейс гитлаба создает MergeRequest - показать кнопку. 
и просит Ответственного с правами Mantainer рассмотреть этот реквест.
При рассмотрении реквеста гитлаб предоставляет следующие возможности:
- можно посмотреть какие коммиты включены в мердж реквест
- можно посмотреть какие файлы и что именно было в них изменно
- можно написать комментарий к любой из строчек файла, и автор сможет написать ответ к этому комментарию
- если добавить коммиты в ветку для которой сделан мерджерквест, то эти коммиты автоматически отобразятся в этом реквесте. нет необходимости создавать новый.
- также гитлаб сразу сообщает можно ли провести слияение или есть конфликты, и предоставляет удобный веб интерфейс, для решения таких конфликтов

при принятии реквеста - появляется новая версия продукта.
Далее возможны варианты:
Некоторым удобно иметь две ветки - master и dev. в мастере лежат релизы, готовые к выкладке на продакшен, в дев - стейдж образы, готовые к финальному тестированию.
если тестирование прошло удачно ветка dev сливается с веткой мастер и коммит помечается тегом релиза.
А ветки для разработки создаются от ветки dev.

Лично я считаю  что достаточно одной ветки мастер, а готовые к продакшен коммиты достаточно помечать командой git tag

Что же делает команда git tag ? как нетрудно догадаться она помечает коммит, дает ему человеческое название.
Позволяя выделить некоторые коммиты из множества существующих.
Обычно в качестве метки ставят версию релиза.

Метка устанавливается командой, если указать хеш, то помечен будет не текущий коммит, а коммит, которые имеет этот хеш
git tag v1.0 <hash>

git push origin --tags - отправить свои метки на сервер

git describe - прекрасная команда, которая позволяет автоматически назначать версию для тестовых образов. 
эта команда возвращает строчку из значения ближайшего тега, количества коммитов между этим тегом и текущим и краткого хеша текущего коммита.

Давайте теперь подведем краткий итог, что вы должны вынести из этой лекции:
- четыре состояния файла в репозитории
- коммит и как его создать
- ветки, их создание и слияние
- удаленные репозитории, получение и отправка коммитов
- связывание локальных и удаленных веток
- теги
- система управления репозитриями - гитлаб
- приемы коллективной разработки



